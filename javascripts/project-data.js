const projects = [
  {
    "name": "ratings",
    "tech": "ruby on rails, angular, postgresql",
    "blurb": "San Francisco restaurant cleanliness scores",
    "description": "ratings (pronounced RAT-ings) uses data from the city of San Francisco's health department to display an interactive map of restaurants in the city and their food safety inspection scores.<br><br>Users can move around the map and automatically get a list of restaurants near the area in which they are dragging, or they can search for their favorite restaurants.<br><br>Businesses are given a score of zero to four rats depending on the severity of their violations.  Historical scores and violations are provided as well as whether or not those violations remain unresolved.<br><br>The backend is straightforward, using Rails and Postgres to expose a simple REST API, consumed by a single page angular js front end.<br><br>In addition to trying to explore public data in a novel way, I used this project as an exercise to familiarize myself with angular.",
    "uri": "http://ratings.availableforfriendship.com",
    "repo": "https://github.com/el-mapache/caveat",
    "src": "rats.jpg",
    "available": true,
    color: 'lipstick',
  },
  {
    "name": "Libre Ipsum",
    "tech": "sinatra, redis, jquery",
    "blurb": "Placeholder text generated from Project Gutenberg",
    "description": "Libre Ipsum uses Project Gutenberg to generator placeholder text suitable for mockups or high-fidelity wireframes. The user simply chooses a book and a number of paragraphs; text from the book is chosen at random.<br><br>The application is composed of the following pieces:<br><br>1) A set of command line utilities handles parsing the Project Gutenberg RSS feed of new books, crawling the website to download them, and performing updating the registry of books<br><br>2). a simple Sinatra application that exposes an API providing paragraphs from the books and has an internal library to generate usable placeholder text (ignoring things like indicies, table of contents, images, etc). This was the most challenging part of writing the app, as it involved a lot of trial and error (and regular expressions!) to figure out the different permutations of invalid content.<br><br>3). a Redis database for simple IP based request throttling. The book parsing can be intensive depending on the book's contents, so it seemed prudent to limit the number of requests. <br><br>4). The front-end, which are some simple event handlers in jQuery/vanilla JS. The copy-to-clipboard functionality used a Flash library, but I recently re-implemented it using the relatively recent browser-based clipboard API.<br><br>",
    "uri": "http://libre-ipsum.availableforfriendship.com",
    "repo": "https://github.com/el-mapache/libre-ipsum",
    "src": "ipsum-2.jpg",
    "available": true,
    color: 'purple',
  },
  {
    "name": "Encoder",
    "tech": "express, redis, angular, ffmpeg",
    "blurb": "ffmpeg-backed audio transcoder",
    "description": "Encoder is a single-page application that allows the user to convert audio files of one format into another one, e.g. from WAV to mp3. Audio files submitted by the user are stored on server until processed by ffmpeg; at that point then the original files are removed, and an email is sent to the user with a download URL.<br><br>This was my first 'web app', and although the functionality is fairly simple, it taught me quite a bit about the considerations that go into making a single page app used by multiple concurrent client. For example, using a worker queue to handle processing the audio files, sending out emails, and removing the old files stored on the server. Or, using Redis as a volatile store for the download links (which expired after a 24 hour period). Even the idea of having a single source of truth to derive the front-end's state was something I had to learn while untangling the jQuery that drove it. <br><br>I later rewrote the server to use express (instead of a custom Node implementation) and angular to replace the jQuery.",
    "uri": "",
    "repo": "https://github.com/el-mapache/encode",
    "src": "encoder.jpg",
    "available": false,
    color: 'blue',
  },
  {
    "name": "Transmission",
    "tech": "express, redis, backbone",
    "blurb": "Real-time file streaming between multiple peers",
    "description": "Transmission takes inspiration from a chat room, with files being the medium of communication between connected clients. One client creates a room and shares that URL with other parties. In the room, every user can then drag as many files as they wish into their browsers and stream them to each of the other connected users. Files will wait to stream until there is at least one other user, and all files are transmitted using a LIFO queue. <br><br>The app uses Redis to keep track of the rooms, and utilizes the BinaryJS to handle transmitting binary data to and from the server over websockets. The front-end is written in backbone, using web sockets on the client side and the File API to extract metadata from, and assemble binary data into files, which are automatically downloaded to the user's computer.",
    "uri": "",
    "repo": "https://github.com/el-mapache/transmission",
    "src": "transmission-2.jpg",
    "available": false,
    color: 'blue',
  },
  {
    "name": "SC-Now Recorder",
    "tech": "vainilla javascript",
    "blurb": "Record module for SourceNow browser-based audio app",
    "description": "This project was written to drive SCNow, Source-Elements' web-based professional audio collaboration tool. Although I used Matt Diamond's excellent RecorderJS library as a starting point, new pieces of functionality had to be added to meet the project's requirements. Users needed to be able to record up to 90 minutes of uncompressed 2 channel PCM audio, and the app had to do so without causing the computer's fan to kick in (adding unwanted noise to the recording).<br><br>Solving this required two major components. Rather than store all the current audio data in a single buffer in memory, I used a small circular buffer which periodically (every few seconds) read data from the buffer and passed it to a web worker, where it was stored in a temporary file via the FileSystem API. When the recording was finished, a header was computed using the total length of the audio data contained in all the files, and those files were concatenated together into a single Blob object.<br><br>Doing this allowed longer record times because it was no longer necessary to store the complete audio data in runtime memory during recording, and because the complete audio data was kept in memory only once, when the file was being assembled.",
    "uri": "https://now.source-elements.com/#!/",
    "repo": "https://github.com/el-mapache/cassette",
    "src": "scnow.jpg",
    "available": true,
    color: 'purple',
  },
  {
    "name": "Hero Quest",
    "tech": "crafty",
    "blurb": "JS versions of Milton Bradley's 90s board game",
    "description": "JavaScript implementation of HeroQuest, a cool Warhammer-lite miniatures-based board game from the 90s. The biggest challenge with this project was one of scope; it taught me that you absolutely must plan out a large project before starting to build it!<br><br>The game's systems are managed by a completely modular architecture. Each of them, down to whether or not a game object can take damage, move, or behave as a ‘solid’ are composed of small, single-purpose modules. This allowed for a lot flexibility in behavior; for example, furniture could easily be made to take damage, or magical items could have their properties decorated, without needing a convoluted system of inheritance.<br><br>Complex behaviors are further abstracted into reusable interfaces. The game also includes a small script evaluator to handle item and magic usage, and custom events that may occur in a given level.<br><br>Although I didn't end up finishing the game, I learned a lot along the way, implementing algorithms like recasting, A* pathfinding, and flood fill, learning about data structures like linked lists, and building a project using an architectural paradigm different from ones I had used before.",
    "uri": "",
    "repo": "https://github.com/el-mapache/hero_quest",
    "src": "hero-quest-2.jpg",
    "available": false,
    color: 'lipstick',
  },
  {
    "name": "Minesweeper",
    "tech": "react",
    "blurb": "Minesweeper just like your Windows 3.1 used to make",
    "description": "JavaScript implementation of the classic game, written to teach myself react. The game only consists of a handful of components, a floodfill class, and some state managed via the Flux pattern.<br><br>There isn't much to say about this project because react made it extremely simple to write! This game is still very hard to beat.",
    "uri": "https://el-mapache.github.io/minesweeper",
    "repo": "https://github.com/el-mapache/minesweeper",
    "src": "minesweeper-2.jpg",
    "available": true,
    color: 'purple',
  },
  {
    name: 'Portfolio',
    tech: 'es6, css3, scss',
    blurb: 'My website!',
    description: 'The website you are currently viewing! Included because it represents a significant reworking of my previous portfolio site. Written to exercise my front-end chops a bit, there are a lot of changes under the hood.<br><br> Bootstrap has been completely removed and replaced with a layout driven by FlexBox and CSS Grid, both of which make designing a page extremely simple. The inline script tag templates and parser are also removed, replaced with ES6 template strings. The page also makes greater use of CSS animations. The javascript driving the site is organized into components, with a top level controller to hold state and provide callbacks and data to the components.',
    uri: 'https://availableforfriendship.com',
    repo: 'https://github.com/el-mapache/website-4.0',
    src: 'portfolio.jpg',
    available: 'true',
    color: 'purple',
  }
];

export default projects;
